\documentclass[10pt, letterpaper]{article}
\usepackage[cm]{fullpage}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{graphicx}
\usepackage[section]{placeins}
\usepackage[table]{xcolor}
\usepackage{amsmath}
\usepackage[margin=0.7in]{geometry}

\algrenewcommand\Return{\State \algorithmicreturn{} }%

\title{0-1 Knapsack}
\author{Daiwei Chen \and Joseph Watts}

\begin{document}
\maketitle
	\begin{abstract}
		0-1 Knapsack is the coined phrase which is used to simply describe the problem of finding the maximum value possible by choosing what items to take, when not everything can be taken.
		Put slightly more formally, given a set of items with all items having a value and weight assigned to them and a bag which allows the user to carry unlimited volume but only a limited weight, the goal is to find the set of items which allow the user to get the maximum value from the chosen items.
		This paper explores different approaches to solving this problem, including both a Dynamic Programming approach along with multiple different Greedy approaches.
	\end{abstract}

\section{Background and Related Work}
The 0-1 Knapsack problem is commonly found in project management and economics in dealing with resource allocation. In an oversimplified manner, how can resources divided so that different departments can get the most valuable work done given their needed resources.
0-1 Knapsack also shows up when working with networking equiptment which try to most efficiently distribute load between different stations.
This is known as load balancing and is used in many common day-to-day technologies.
0-1 Knapsack was also used as a key part of the design of public-private keys when first made during the 1970's. A private key is generated with an easy knapsack problem, and then a hard knapsack is derrived by it and this is what is used as the public key.
\section{Greedy Algorithm}

\section{Dynamic Algorithm}
This dynamic programming solution builds a table of size $n$x$W+1$ where $n$ is the number of available items, and $W$ is the maximum weight that is available. For each row (i) and each column (j) set that row's first column equal to zero. if j is less than the first item in the item list's weight then set the first row's column at j equal to the value of the first item in the item's list.
Now that the first row and column have been populated, the remaining elements can also be calculated.
If j is less than the current item's weight, then the current row and column's value is set to the value held at the the previous row and the current column. Otherwise the value found at the current row and column is set as the maximum between the value at the previous row and current column and the value found at the prevoius row and current column minus the current items weight. This is in addition to the current items value. The optimal value can now be read at K[$n-1$][$W$]
\section{Experimental Setup}

\section{Results}
	% Diagram showing the average time between different approaches
	\begin{figure}[htbp]
		\begin{center}
			\includegraphics[width=0.70\textwidth]{python/accuracyGraph.png}
			\caption{Algorithm Accuracy for Taking Items Given Maximum Weight $n$}
			\label{fig:accuracy-graph}
		\end{center}
	\end{figure}
	% Diagram showing the % accuracy of different approaches
	\begin{figure}[htbp]
		\begin{center}
			\includegraphics[width=0.70\textwidth]{python/timeGraph.png}
			\caption{Time to Calculate Items to take with Maximum Available Weight $n$}
			\label{fig:time-graph}
		\end{center}
	\end{figure}
\section{Conclusions}

\end{document}
